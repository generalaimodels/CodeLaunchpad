<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 15: Object-Oriented Programming (OOP) ğŸš€</title>
</head>
<body>
    <h1>Chapter 15: Object-Oriented Programming (OOP) in JavaScript - Unleash the Power of Objects! ğŸš€</h1>

    <script>
        // ğŸš€ Chapter 15: Object-Oriented Programming (OOP) - Structure, Reuse, and Maintainability! ğŸš€

        // ğŸ¯ 1. Classes and Objects - Blueprints and Instances  blueprints and cookies ğŸª

        // Object-Oriented Programming (OOP): Paradigm organizing code around "objects". ğŸ“¦
        // - Objects bundle data (properties/attributes) and behavior (methods/functions). ğŸ
        // - OOP promotes modularity, reusability, and maintainability. ğŸ§©

        // Class: Blueprint or template for creating objects. ğŸ—ºï¸
        // - Defines the structure (properties) and capabilities (methods) of objects. ğŸ—ï¸
        // - Think of a class as a cookie cutter. ğŸªğŸ”ª

        // Object: Instance of a class. Concrete realization of the blueprint. ğŸ§±
        // - Actual entities in your program, created from a class. ğŸª
        // - Think of objects as cookies made with the cookie cutter. ğŸª

        // Class Definition Syntax (ES6 'class' keyword):
        //
        // class ClassName {
        //     constructor(param1, param2, ...) { // Constructor - initializes object properties
        //         this.propertyName1 = param1;
        //         this.propertyName2 = param2;
        //         // ...
        //     }
        //
        //     methodName1() { // Method 1 - object behavior
        //         // ... method logic ...
        //     }
        //
        //     methodName2() { // Method 2 - object behavior
        //         // ... method logic ...
        //     }
        //     // ... more methods ...
        // }

        // Example 1: Dog Class and Objects ğŸ¶ğŸ¾
        console.log("\nExample 1: Dog Class and Objects");
        class Dog { // ğŸ• Class named 'Dog' - blueprint for dog objects
            constructor(name, breed) { // ğŸ—ï¸ Constructor - called when new Dog object is created
                console.log("Dog constructor called for:", name); // Log when constructor is invoked
                this.name = name;   // ğŸ·ï¸ 'this.name' - property of the Dog object, assigned 'name' argument
                this.breed = breed; // ğŸ·ï¸ 'this.breed' - property of the Dog object, assigned 'breed' argument
            }

            bark() { // ğŸ—£ï¸ Method 'bark' - behavior of Dog objects
                console.log("Woof! ğŸ¶"); // Dog's bark sound
            }

            describe() { // ğŸ“ Method 'describe' - provides information about the Dog
                console.log(`Dog Name: ${this.name}, Breed: ${this.breed}`); // Uses template literals for string formatting
            }
        }
        // Class Diagram (Simplified):
        //
        //    Dog Class ğŸ•
        //    -----------------
        //    - name: string
        //    - breed: string
        //    -----------------
        //    + constructor(name, breed)
        //    + bark()
        //    + describe()

        // Creating Objects (Instances) of Dog Class using 'new' keyword:
        const dog1 = new Dog("Charlie", "Labrador");     // ğŸª Creating 'dog1' object, instance of 'Dog' class
        const dog2 = new Dog("Bella", "Golden Retriever"); // ğŸª Creating 'dog2' object, another instance of 'Dog' class

        console.log("Dog 1 Name:", dog1.name); // Accessing 'name' property of 'dog1' object using dot notation '.'
        dog1.bark();                           // Calling 'bark' method on 'dog1' object using dot notation '.'
        dog1.describe();                      // Calling 'describe' method on 'dog1' object
        dog2.describe();                      // Calling 'describe' method on 'dog2' object

        // Example 2: Car Class and Objects ğŸš—ğŸ’¨
        console.log("\nExample 2: Car Class and Objects");
        class Car { // ğŸš— Class named 'Car' - blueprint for car objects
            constructor(make, model, year) { // ğŸ—ï¸ Constructor for Car objects
                this.make = make;
                this.model = model;
                this.year = year;
                this.speed = 0; // Initial speed of the car is 0
            }

            accelerate(increment) { // ğŸ’¨ Method to increase car speed
                this.speed += increment;
                console.log(`Accelerating... Current speed: ${this.speed} km/h`);
            }

            brake(decrement) { // ğŸ›‘ Method to decrease car speed
                this.speed -= decrement;
                if (this.speed < 0) {
                    this.speed = 0; // Speed cannot be negative
                }
                console.log(`Braking... Current speed: ${this.speed} km/h`);
            }

            getSpeed() { // â„¹ï¸ Method to get current car speed
                return this.speed;
            }

            describeCar() { // ğŸ“ Method to describe the car
                console.log(`Car: ${this.year} ${this.make} ${this.model}, Speed: ${this.speed} km/h`);
            }
        }

        const car1 = new Car("Toyota", "Camry", 2022); // ğŸš— Creating 'car1' object
        const car2 = new Car("Tesla", "Model S", 2023);  // ğŸš— Creating 'car2' object

        car1.accelerate(20); // Increase car1 speed
        car1.accelerate(30); // Increase car1 speed further
        car1.describeCar();  // Describe car1 state
        car2.describeCar();  // Describe car2 state (initial speed 0)
        car1.brake(10);      // Decrease car1 speed
        car1.describeCar();  // Describe car1 state after braking


        // ğŸ—ï¸ 2. Constructors and Prototypes - Initialization and Inheritance Foundation ğŸ—ï¸

        // Constructor: Special method within a class (named 'constructor'). ğŸ§±
        // - Automatically called when a new object is created using 'new' keyword. âš™ï¸
        // - Primary purpose: Initialize object properties. ğŸ› ï¸
        // - If no constructor is explicitly defined, a default constructor is implicitly provided. ğŸ‘»

        // 'this' Keyword: Refers to the CURRENT object instance within a class. ğŸ¯
        // - Used inside constructor and methods to access and manipulate object's properties. ğŸ“Œ

        // Prototypes: Mechanism for inheritance and property lookup in JavaScript. ğŸ§¬
        // - Every object in JS has an associated prototype object (except null prototype objects). ğŸ”—
        // - Prototype is itself an object, and can have its own prototype (prototype chain). â›“ï¸
        // - When you access a property of an object:
        //   1. JS first looks at the object's OWN properties. ğŸ‘€
        //   2. If not found, JS looks at the object's PROTOTYPE's properties. ğŸ”
        //   3. If still not found, JS looks at the prototype's prototype, and so on... (prototype chain) ğŸªœ
        //   4. Until property is found, or the end of the prototype chain is reached (null prototype). ğŸ›‘

        // Example 1: Animal Class, Constructor, and Prototype ğŸ…ğŸŒ¿
        console.log("\nExample 1: Animal Class, Constructor, and Prototype");
        class Animal { // ğŸ… Class 'Animal'
            constructor(name) { // ğŸ—ï¸ Constructor for Animal, takes 'name' argument
                console.log("Animal constructor called for:", name); // Log constructor invocation
                this.name = name; // ğŸ·ï¸ Initialize 'name' property of Animal object
            }

            eat() { // ğŸ½ï¸ Method 'eat' for Animal
                console.log("Animal eating generically ğŸŒ¿");
            }
        }

        const animal = new Animal("Tiger"); // ğŸ… Creating 'animal' object of class 'Animal'
        console.log("Animal Name:", animal.name); // Accessing 'name' property
        animal.eat();                       // Calling 'eat' method

        console.log("Animal Class Prototype:", Animal.prototype); // Accessing the prototype object of 'Animal' class
        console.log("Animal Object's __proto__:", animal.__proto__); // Accessing the prototype of 'animal' object (internal property)

        console.log("animal.__proto__ === Animal.prototype:", animal.__proto__ === Animal.prototype); // âœ… They are the SAME object!

        // Prototype Relationship Diagram:
        //
        //  Animal Class (Blueprint) ğŸ…       Animal.prototype (Prototype Object) âš™ï¸
        //  -------------------------       ------------------------------------
        //  constructor(name)             constructor: [Function: Animal]  <- points back to Animal class
        //  eat()                         eat: [Function: eat]             <- 'eat' method is here
        //                                __proto__: Object                 <- Prototype chain continues...
        //                                (Object.prototype by default)

        //  animal Object (Instance) ğŸ¾       animal.__proto__ (Points to Animal.prototype) ğŸ”—
        //  --------------------------       ------------------------------------
        //  name: "Tiger"                  (Same as Animal.prototype)
        //  __proto__: ... ğŸ”—--------------->

        // Example 2: Prototype Chain - Method Lookup ğŸªœğŸ”
        console.log("\nExample 2: Prototype Chain and Method Lookup");
        const animalProto = Animal.prototype; // Get Animal's prototype
        const hasEatMethod = animalProto.hasOwnProperty('eat'); // Check if 'eat' method is directly on Animal's prototype
        const hasToStringMethod = animalProto.hasOwnProperty('toString'); // Check for 'toString' method

        console.log("Animal.prototype has 'eat' method (hasOwnProperty):", hasEatMethod);   // Output: true - 'eat' is defined in Animal.prototype
        console.log("Animal.prototype has 'toString' method (hasOwnProperty):", hasToStringMethod); // Output: false - 'toString' is NOT directly on Animal.prototype

        console.log("animal object's 'toString' method:", animal.toString); // Access 'toString' method on 'animal' object (inherited from Object.prototype)
        // 'toString' is not directly on Animal.prototype, but inherited from Object.prototype via prototype chain.

        // Prototype Chain Visualization (Simplified):
        //
        //  animal Object ğŸ¾ --> animal.__proto__ (Animal.prototype) âš™ï¸ --> Animal.prototype.__proto__ (Object.prototype) ğŸ“¦ --> Object.prototype.__proto__ (null) ğŸ›‘
        //                                               ^                                         ^
        //                                               | 'eat' method is here                  | 'toString', 'valueOf' methods are here (among others)
        //                                               ------------------------------------------

        // ğŸ§¬ 3. Inheritance - Code Reusability and Class Hierarchy ğŸ§¬

        // Inheritance: Mechanism where a class (child class/subclass) inherits properties and methods from another class (parent class/superclass). ğŸ‘ª -> ğŸ‘¶
        // - Promotes code reuse - avoid rewriting common properties and methods. â™»ï¸
        // - Creates a hierarchy of classes - organize code based on "is-a-kind-of" relationships. ğŸŒ²
        //   - e.g., Dog "is-a-kind-of" Animal, Car "is-a-kind-of" Vehicle.

        // 'extends' Keyword: Used to establish inheritance - declare a class as a subclass of another. ğŸ”—
        // 'super()' Keyword: Used in subclass constructor to: âš™ï¸
        //   1. Call the parent class's constructor - initialize inherited properties. ğŸ§±
        //   2. Access parent class's methods from within the subclass (e.g., super.parentMethod()). ğŸ“

        // Example 1: Dog Class Inheriting from Animal Class ğŸ• -> ğŸ…
        console.log("\nExample 1: Dog Class Inheriting from Animal Class");
        class AnimalParent { // ğŸ… Parent class 'AnimalParent' (renamed to avoid conflict with earlier Animal)
            constructor(name) { // ğŸ—ï¸ Parent constructor - takes 'name'
                console.log("AnimalParent constructor called for:", name);
                this.name = name;
            }
            eat() { // ğŸ½ï¸ Parent 'eat' method
                console.log("AnimalParent eating generically ğŸŒ¿");
            }
        }

        class DogChild extends AnimalParent { // ğŸ• Child class 'DogChild' EXTENDS 'AnimalParent' - inherits from AnimalParent
            constructor(name, breed) { // ğŸ—ï¸ Child constructor - takes 'name' and 'breed'
                super(name);        // ğŸ“ super(name) - Call the constructor of the PARENT class (AnimalParent) with 'name' argument
                console.log("DogChild constructor called for:", name, breed); // Log after parent constructor
                this.breed = breed; // ğŸ·ï¸ Initialize 'breed' property - specific to DogChild
            }

            bark() { // ğŸ—£ï¸ Child class specific method 'bark'
                console.log("Woof! ğŸ¶ (from DogChild)");
            }

            eat() { // ğŸ½ï¸ Method OVERRIDING - Child class provides its OWN implementation of 'eat' method
                super.eat();    // ğŸ“ super.eat() - Call the 'eat' method of the PARENT class (AnimalParent)
                console.log("DogChild eating specifically ğŸ–"); // Add specific behavior for DogChild 'eat'
            }
        }

        const myDog = new DogChild("Buddy", "German Shepherd"); // ğŸ• Creating 'myDog' object of 'DogChild' class
        console.log("My Dog's Name:", myDog.name); // Inherited property 'name' from AnimalParent
        console.log("My Dog's Breed:", myDog.breed); // Property 'breed' specific to DogChild
        myDog.eat();            // Calling 'eat' method - DogChild's version (overrides AnimalParent's)
        myDog.bark();           // Calling 'bark' method - specific to DogChild

        // Inheritance Hierarchy Diagram:
        //
        //        AnimalParent (Superclass) ğŸ…
        //            ^
        //            | extends
        //        DogChild (Subclass) ğŸ•
        //
        // DogChild inherits: 'name' property, 'eat()' method from AnimalParent.
        // DogChild extends: adds 'breed' property, 'bark()' method, and overrides 'eat()' method.

        // Example 2: Vehicle and Car Inheritance Hierarchy ğŸš— -> Vehicle ğŸšŒ
        console.log("\nExample 2: Vehicle and Car Inheritance Hierarchy");
        class Vehicle { // ğŸšŒ Parent class 'Vehicle'
            constructor(make, model) { // ğŸ—ï¸ Vehicle constructor - takes 'make', 'model'
                this.make = make;
                this.model = model;
            }
            startEngine() { // âš™ï¸ Vehicle 'startEngine' method
                console.log("Vehicle engine started! ğŸš—ğŸ’¨");
            }
            stopEngine() { // ğŸ›‘ Vehicle 'stopEngine' method
                console.log("Vehicle engine stopped! ğŸ›‘");
            }
            describeVehicle() { // ğŸ“ Vehicle 'describeVehicle' method
                console.log(`Vehicle: ${this.make} ${this.model}`);
            }
        }

        class CarSubclass extends Vehicle { // ğŸš— Child class 'CarSubclass' extends 'Vehicle'
            constructor(make, model, numDoors) { // ğŸ—ï¸ CarSubclass constructor - takes 'make', 'model', 'numDoors'
                super(make, model); // ğŸ“ Call Vehicle constructor with 'make', 'model'
                this.numDoors = numDoors; // ğŸ·ï¸ Initialize 'numDoors' property - specific to CarSubclass
            }
            honk() { // ğŸ“¢ CarSubclass specific method 'honk'
                console.log("Honk Honk! ğŸ“¢ğŸš—");
            }
            describeCarSubclass() { // ğŸ“ CarSubclass 'describeCarSubclass' method
                super.describeVehicle(); // ğŸ“ Call parent 'describeVehicle' method for common description
                console.log(`It's a car with ${this.numDoors} doors.`); // Add car-specific details
            }
        }

        const myCar = new CarSubclass("Honda", "Civic", 4); // ğŸš— Creating 'myCar' object of 'CarSubclass'
        myCar.startEngine();      // Inherited 'startEngine' method from Vehicle
        myCar.honk();             // CarSubclass specific 'honk' method
        myCar.describeCarSubclass(); // CarSubclass specific 'describeCarSubclass' method
        myCar.stopEngine();       // Inherited 'stopEngine' method from Vehicle

        // Inheritance Hierarchy Diagram:
        //
        //        Vehicle (Superclass) ğŸšŒ
        //            ^
        //            | extends
        //        CarSubclass (Subclass) ğŸš—
        //
        // CarSubclass inherits: 'make', 'model' properties, 'startEngine()', 'stopEngine()', 'describeVehicle()' methods.
        // CarSubclass extends: adds 'numDoors' property, 'honk()' method, 'describeCarSubclass()' method (extending description).


        // ğŸ­ 4. Polymorphism - Many Forms, One Interface ğŸ­

        // Polymorphism (Greek: "many forms"): Ability of objects of DIFFERENT classes to respond to the SAME method call in their OWN way. ğŸ­
        // - "One interface, multiple implementations." ğŸ”„
        // - Achieved in JavaScript through METHOD OVERRIDING in subclasses. âš™ï¸ -> ğŸ­
        //   - Subclass provides its own implementation of a method already defined in its superclass. âœï¸

        // Example 1: Animal Sounds - Polymorphic Behavior ğŸ¾ğŸµ
        console.log("\nExample 1: Animal Sounds - Polymorphism");
        class AnimalPoly { // ğŸ¾ Base class 'AnimalPoly' (renamed to avoid conflict)
            constructor(name) {
                this.name = name;
            }
            makeSound() { // ğŸµ Base class 'makeSound' method - generic sound
                console.log("Generic animal sound ğŸ¾ğŸµ");
            }
        }

        class DogPoly extends AnimalPoly { // ğŸ• Subclass 'DogPoly' extends 'AnimalPoly'
            constructor(name, breed) {
                super(name);
                this.breed = breed;
            }
            makeSound() { // ğŸµ Method OVERRIDING - DogPoly provides its own 'makeSound'
                console.log("Woof! Woof! ğŸ¶ğŸµ"); // Dog-specific sound
            }
        }

        class CatPoly extends AnimalPoly { // ğŸˆ Subclass 'CatPoly' extends 'AnimalPoly'
            makeSound() { // ğŸµ Method OVERRIDING - CatPoly provides its own 'makeSound'
                console.log("Meow! Meow! ğŸˆğŸµ"); // Cat-specific sound
            }
        }

        const genericAnimal = new AnimalPoly("Generic Animal"); // ğŸ¾ Generic Animal object
        const petDog = new DogPoly("Rover", "Beagle");       // ğŸ• Dog object
        const petCat = new CatPoly("Whiskers");            // ğŸˆ Cat object

        genericAnimal.makeSound(); // Calls AnimalPoly's makeSound - Generic animal sound ğŸ¾ğŸµ
        petDog.makeSound();      // Calls DogPoly's makeSound - Woof! Woof! ğŸ¶ğŸµ (Polymorphic behavior)
        petCat.makeSound();      // Calls CatPoly's makeSound - Meow! Meow! ğŸˆğŸµ (Polymorphic behavior)

        // Polymorphism Diagram:
        //
        //  AnimalPoly (Base Class) ğŸ¾          DogPoly (Subclass) ğŸ•           CatPoly (Subclass) ğŸˆ
        //  -----------------------          -----------------------          -----------------------
        //  makeSound() -> Generic ğŸµ         makeSound() -> Woof! ğŸ¶ğŸµ        makeSound() -> Meow! ğŸˆğŸµ
        //
        //  Each subclass provides a specialized implementation of makeSound(), demonstrating polymorphism.

        // Example 2: Shape Calculation - Polymorphic Area Calculation ğŸ“ğŸ“
        console.log("\nExample 2: Shape Area Calculation - Polymorphism");
        class Shape { // ğŸ“ Base class 'Shape'
            calculateArea() { // ğŸ“ Base class 'calculateArea' - generic (returns 0 as default)
                console.log("Calculating area for a generic shape (default 0)");
                return 0; // Default area for generic shape
            }
        }

        class Circle extends Shape { // âšª Subclass 'Circle' extends 'Shape'
            constructor(radius) {
                super();
                this.radius = radius;
            }
            calculateArea() { // ğŸ“ Method OVERRIDING - Circle provides its own 'calculateArea'
                const area = Math.PI * this.radius * this.radius; // Circle area formula
                console.log(`Calculating area for Circle (radius: ${this.radius})`);
                return area;
            }
        }

        class Square extends Shape { // â¬œ Subclass 'Square' extends 'Shape'
            constructor(side) {
                super();
                this.side = side;
            }
            calculateArea() { // ğŸ“ Method OVERRIDING - Square provides its own 'calculateArea'
                const area = this.side * this.side; // Square area formula
                console.log(`Calculating area for Square (side: ${this.side})`);
                return area;
            }
        }

        const genericShape = new Shape();         // ğŸ“ Generic Shape object
        const myCircle = new Circle(5);          // âšª Circle object with radius 5
        const mySquare = new Square(4);          // â¬œ Square object with side 4

        console.log("Generic Shape Area:", genericShape.calculateArea()); // Calls Shape's calculateArea - 0
        console.log("Circle Area:", myCircle.calculateArea());       // Calls Circle's calculateArea - Circle specific calculation
        console.log("Square Area:", mySquare.calculateArea());       // Calls Square's calculateArea - Square specific calculation

        // Polymorphism Diagram:
        //
        //  Shape (Base Class) ğŸ“            Circle (Subclass) âšª             Square (Subclass) â¬œ
        //  ---------------------            ---------------------            ---------------------
        //  calculateArea() -> 0 ğŸ“         calculateArea() -> Circle Area ğŸ“  calculateArea() -> Square Area ğŸ“
        //
        // Each subclass calculates area differently, demonstrating polymorphic behavior based on shape type.


        // ğŸ”’ 5. Encapsulation - Data Hiding and Controlled Access ğŸ”’

        // Encapsulation: Bundling of data (properties) and methods that operate on that data within a single unit (class). ğŸ“¦ğŸ”’
        // - Hiding internal details (implementation) of an object from the outside world. ğŸ™ˆ
        // - Exposing only a controlled interface (public methods) to interact with the object. ğŸ”“
        // - Benefits:
        //   - Data protection: Prevent direct, unintended modification of internal state. ğŸ›¡ï¸
        //   - Code maintainability: Easier to change internal implementation without breaking external code. ğŸ› ï¸
        //   - Abstraction: Simplify object usage by hiding complex internal workings. ğŸ§˜

        // JavaScript Encapsulation (Achieved through closures in older JS, and class features in ES6, but no truly "private" members like in some languages):
        // - In JavaScript, true private members (with strict enforcement at runtime) are not natively available in the traditional sense (prior to ES2019/private class fields - more advanced).
        // - Encapsulation is often achieved through conventions and closures to create a degree of privacy and controlled access. ğŸ¤

        // Example 1: Encapsulation using Closures (Simulating Private Members) ğŸ™ˆğŸ”’
        console.log("\nExample 1: Encapsulation using Closures");
        function createPersonEncapsulated(name, age) { // ğŸ­ Factory function to create 'person' objects with encapsulation
            let _name = name; // ğŸ™ˆ '_name' - "Private" variable (lexically scoped within createPersonEncapsulated)
            let _age = age;   // ğŸ™ˆ '_age'  - "Private" variable

            return { // ğŸ“¦ Return an object - public interface to interact with the "private" data
                getName: function() { // ğŸ”“ Public method 'getName' - provides READ access to '_name'
                    return _name;
                },
                getAge: function() {  // ğŸ”“ Public method 'getAge' - provides READ access to '_age'
                    return _age;
                },
                setAge: function(newAge) { // ğŸ”“ Public method 'setAge' - provides CONTROLLED WRITE access to '_age'
                    if (typeof newAge === 'number' && newAge >= 0 && newAge <= 120) { // Input validation - age must be valid
                        _age = newAge; // Update '_age' only if validation passes
                        console.log("Age updated to:", _age);
                    } else {
                        console.warn("Invalid age value. Age not updated."); // Warning for invalid age
                    }
                }
                // No direct public access to '_name' or '_age' - encapsulated! ğŸ”’
            };
        }

        const personEncapsulated = createPersonEncapsulated("Alice", 28); // ğŸ‘¤ Create encapsulated 'personEncapsulated' object
        console.log("Encapsulated Person Name:", personEncapsulated.getName()); // Access name via getter
        console.log("Encapsulated Person Age:", personEncapsulated.getAge());   // Access age via getter

        personEncapsulated.setAge(30); // Update age via setter (valid age)
        console.log("Encapsulated Person Age after setAge(30):", personEncapsulated.getAge()); // Verify updated age

        personEncapsulated.setAge(-5); // Attempt to set invalid age (negative) - validation in setter prevents it
        console.log("Encapsulated Person Age after setAge(-5):", personEncapsulated.getAge()); // Age remains unchanged

        // Attempting direct access to '_name' or '_age' from outside will NOT work - they are not properties of 'personEncapsulated' object.
        // console.log(personEncapsulated._name); // Error - '_name' is not a property of 'personEncapsulated'
        // console.log(personEncapsulated._age);  // Error - '_age' is not a property of 'personEncapsulated'

        // Encapsulation Diagram (Conceptual):
        //
        //  personEncapsulated Object ğŸ‘¤ğŸ”’
        //  --------------------------
        //  (Internal - via closure)   |  Public Interface (Methods) ğŸ”“
        //  --------------------------|-----------------------------
        //  _name: "Alice"  ğŸ™ˆ         |  getName(): returns _name
        //  _age: 28       ğŸ™ˆ         |  getAge(): returns _age
        //                             |  setAge(newAge): validates & updates _age
        //  --------------------------|-----------------------------
        //  External code can ONLY interact with the object through the defined public methods, not directly with internal data. ğŸ”’


        // âœ… 6. Example (from your instructions): Revisit Dog Class ğŸ•

        console.log("\nExample from Instructions: Dog Class");
        class DogInstruction { // ğŸ• Class 'DogInstruction' (revisited from instructions)
            constructor(name, breed) {
                this.name = name;
                this.breed = breed;
            }
            bark() {
                console.log("Woof! ğŸ¶ (Instruction Example)");
            }
        }
        const myDogInstruction = new DogInstruction("Buddy", "Labrador"); // ğŸ• Create 'myDogInstruction' object
        myDogInstruction.bark(); // Call 'bark' method - Output: Woof! ğŸ¶ (Instruction Example)


        // ğŸ‰ Chapter 15 Completed! You are now equipped with OOP principles in JavaScript! ğŸš€
        console.log("\nChapter 15: Object-Oriented Programming (OOP) - Completed! ğŸš€ Embrace OOP for structured, reusable, and maintainable code! âœ¨");

    </script>
</body>
</html>